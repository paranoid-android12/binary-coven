-- Binary Coven LMS Database Schema
-- This migration creates all necessary tables for the Learning Management System

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================================
-- ADMIN SETTINGS TABLE
-- ============================================================================
-- Stores admin configuration including password hash
CREATE TABLE IF NOT EXISTS admin_settings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  password_hash TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

-- Insert default admin (password will be set via environment variable)
INSERT INTO admin_settings (password_hash)
VALUES ('$2a$10$placeholder') -- This will be updated on first admin login
ON CONFLICT DO NOTHING;

-- ============================================================================
-- SESSION CODES TABLE
-- ============================================================================
-- Stores session codes generated by admin with validity periods
CREATE TABLE IF NOT EXISTS session_codes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  code VARCHAR(20) UNIQUE NOT NULL,
  validity_start TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  validity_end TIMESTAMP WITH TIME ZONE NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  max_students INTEGER DEFAULT NULL, -- NULL = unlimited
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  created_by VARCHAR(100) DEFAULT 'admin'
);

-- Index for faster code lookups
CREATE INDEX idx_session_codes_code ON session_codes(code);
CREATE INDEX idx_session_codes_validity ON session_codes(validity_start, validity_end);

-- ============================================================================
-- STUDENT PROFILES TABLE
-- ============================================================================
-- Stores student accounts linked to session codes
-- Students can have multiple profiles for different session codes
CREATE TABLE IF NOT EXISTS student_profiles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  username VARCHAR(100) NOT NULL,
  password_hash TEXT NOT NULL,
  session_code_id UUID NOT NULL REFERENCES session_codes(id) ON DELETE CASCADE,
  display_name VARCHAR(200),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  last_login TIMESTAMP WITH TIME ZONE,
  is_active BOOLEAN DEFAULT TRUE,

  -- Composite unique constraint: username is unique per session code
  UNIQUE(username, session_code_id)
);

-- Indexes for faster lookups
CREATE INDEX idx_student_profiles_username ON student_profiles(username);
CREATE INDEX idx_student_profiles_session_code ON student_profiles(session_code_id);
CREATE INDEX idx_student_profiles_created_at ON student_profiles(created_at);

-- ============================================================================
-- GAME SAVES TABLE
-- ============================================================================
-- Stores complete game state for each student profile
CREATE TABLE IF NOT EXISTS game_saves (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  student_profile_id UUID NOT NULL REFERENCES student_profiles(id) ON DELETE CASCADE,
  game_state JSONB NOT NULL, -- Complete game state: grids, entities, resources, etc.
  save_name VARCHAR(100) DEFAULT 'autosave',
  last_saved TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  save_version INTEGER DEFAULT 1, -- For tracking save format versions

  -- One active save per student profile
  UNIQUE(student_profile_id, save_name)
);

-- Indexes for faster queries
CREATE INDEX idx_game_saves_student_profile ON game_saves(student_profile_id);
CREATE INDEX idx_game_saves_last_saved ON game_saves(last_saved);

-- GIN index for JSONB queries
CREATE INDEX idx_game_saves_game_state ON game_saves USING GIN (game_state);

-- ============================================================================
-- QUEST PROGRESS TABLE
-- ============================================================================
-- Tracks quest-level progress for each student
CREATE TABLE IF NOT EXISTS quest_progress (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  student_profile_id UUID NOT NULL REFERENCES student_profiles(id) ON DELETE CASCADE,
  quest_id VARCHAR(100) NOT NULL,
  quest_title VARCHAR(200),
  state VARCHAR(50) NOT NULL, -- locked, available, active, completed, failed
  current_phase_index INTEGER DEFAULT 0,
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  time_spent_seconds INTEGER DEFAULT 0, -- Total time spent in seconds
  attempts INTEGER DEFAULT 0,
  score INTEGER,
  phase_progress JSONB DEFAULT '{}', -- Detailed phase progress data

  UNIQUE(student_profile_id, quest_id)
);

-- Indexes for analytics queries
CREATE INDEX idx_quest_progress_student_profile ON quest_progress(student_profile_id);
CREATE INDEX idx_quest_progress_quest_id ON quest_progress(quest_id);
CREATE INDEX idx_quest_progress_state ON quest_progress(state);
CREATE INDEX idx_quest_progress_completed_at ON quest_progress(completed_at);

-- ============================================================================
-- OBJECTIVE PROGRESS TABLE
-- ============================================================================
-- Tracks individual objective completion within quest phases
CREATE TABLE IF NOT EXISTS objective_progress (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  student_profile_id UUID NOT NULL REFERENCES student_profiles(id) ON DELETE CASCADE,
  quest_id VARCHAR(100) NOT NULL,
  phase_id VARCHAR(100) NOT NULL,
  objective_index INTEGER NOT NULL,
  objective_description TEXT,
  completed_at TIMESTAMP WITH TIME ZONE,
  attempts INTEGER DEFAULT 0,
  time_spent_seconds INTEGER DEFAULT 0,
  hints_used INTEGER DEFAULT 0,

  UNIQUE(student_profile_id, quest_id, phase_id, objective_index)
);

-- Indexes for detailed analytics
CREATE INDEX idx_objective_progress_student_profile ON objective_progress(student_profile_id);
CREATE INDEX idx_objective_progress_quest ON objective_progress(quest_id, phase_id);
CREATE INDEX idx_objective_progress_completed_at ON objective_progress(completed_at);

-- ============================================================================
-- CODE EXECUTIONS TABLE
-- ============================================================================
-- Tracks every code execution attempt by students
CREATE TABLE IF NOT EXISTS code_executions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  student_profile_id UUID NOT NULL REFERENCES student_profiles(id) ON DELETE CASCADE,
  quest_id VARCHAR(100),
  phase_id VARCHAR(100),
  code_window_id VARCHAR(100),
  code_content TEXT NOT NULL,
  execution_result JSONB, -- {success: boolean, errors: [], output: string, executionTime: number}
  executed_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
  entity_id VARCHAR(100), -- Which entity ran the code (player or drone)
  execution_duration_ms INTEGER
);

-- Indexes for querying execution history
CREATE INDEX idx_code_executions_student_profile ON code_executions(student_profile_id);
CREATE INDEX idx_code_executions_quest ON code_executions(quest_id, phase_id);
CREATE INDEX idx_code_executions_executed_at ON code_executions(executed_at);

-- GIN index for searching execution results
CREATE INDEX idx_code_executions_result ON code_executions USING GIN (execution_result);

-- ============================================================================
-- LEARNING ANALYTICS EVENTS TABLE
-- ============================================================================
-- General event tracking for learning analytics
CREATE TABLE IF NOT EXISTS learning_events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  student_profile_id UUID NOT NULL REFERENCES student_profiles(id) ON DELETE CASCADE,
  event_type VARCHAR(100) NOT NULL, -- quest_started, quest_completed, phase_started, etc.
  event_data JSONB, -- Flexible event data
  quest_id VARCHAR(100),
  phase_id VARCHAR(100),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

-- Indexes for event queries
CREATE INDEX idx_learning_events_student_profile ON learning_events(student_profile_id);
CREATE INDEX idx_learning_events_type ON learning_events(event_type);
CREATE INDEX idx_learning_events_quest ON learning_events(quest_id);
CREATE INDEX idx_learning_events_created_at ON learning_events(created_at);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE admin_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_codes ENABLE ROW LEVEL SECURITY;
ALTER TABLE student_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE game_saves ENABLE ROW LEVEL SECURITY;
ALTER TABLE quest_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE objective_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE code_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE learning_events ENABLE ROW LEVEL SECURITY;

-- Admin settings: Only accessible via service role (backend only)
CREATE POLICY "Admin settings are private" ON admin_settings
  FOR ALL USING (false);

-- Session codes: Admin can do all, students can only read active codes
CREATE POLICY "Session codes are viewable by authenticated users" ON session_codes
  FOR SELECT USING (auth.role() = 'authenticated');

-- Student profiles: Students can only see/update their own profile
CREATE POLICY "Students can view their own profile" ON student_profiles
  FOR SELECT USING (auth.uid()::text = id::text);

CREATE POLICY "Students can update their own profile" ON student_profiles
  FOR UPDATE USING (auth.uid()::text = id::text);

-- Game saves: Students can only access their own saves
CREATE POLICY "Students can manage their own saves" ON game_saves
  FOR ALL USING (student_profile_id::text = auth.uid()::text);

-- Quest progress: Students can only access their own progress
CREATE POLICY "Students can manage their own quest progress" ON quest_progress
  FOR ALL USING (student_profile_id::text = auth.uid()::text);

-- Objective progress: Students can only access their own progress
CREATE POLICY "Students can manage their own objective progress" ON objective_progress
  FOR ALL USING (student_profile_id::text = auth.uid()::text);

-- Code executions: Students can only access their own executions
CREATE POLICY "Students can manage their own code executions" ON code_executions
  FOR ALL USING (student_profile_id::text = auth.uid()::text);

-- Learning events: Students can only access their own events
CREATE POLICY "Students can manage their own learning events" ON learning_events
  FOR ALL USING (student_profile_id::text = auth.uid()::text);

-- ============================================================================
-- FUNCTIONS AND TRIGGERS
-- ============================================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = TIMEZONE('utc', NOW());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for admin_settings
CREATE TRIGGER update_admin_settings_updated_at
  BEFORE UPDATE ON admin_settings
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Function to check session code validity
CREATE OR REPLACE FUNCTION is_session_code_valid(code_to_check VARCHAR)
RETURNS BOOLEAN AS $$
DECLARE
  code_record RECORD;
  check_time TIMESTAMP WITH TIME ZONE;
BEGIN
  check_time := TIMEZONE('utc', NOW());

  SELECT * INTO code_record
  FROM session_codes
  WHERE code = code_to_check
    AND is_active = TRUE
    AND validity_start <= check_time
    AND validity_end >= check_time;

  RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to get student count for a session code
CREATE OR REPLACE FUNCTION get_session_student_count(code_id UUID)
RETURNS INTEGER AS $$
DECLARE
  student_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO student_count
  FROM student_profiles
  WHERE session_code_id = code_id
    AND is_active = TRUE;

  RETURN student_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- VIEWS FOR ADMIN DASHBOARD
-- ============================================================================

-- View for session code statistics
CREATE OR REPLACE VIEW session_code_stats AS
SELECT
  sc.id,
  sc.code,
  sc.validity_start,
  sc.validity_end,
  sc.is_active,
  sc.created_at,
  COUNT(DISTINCT sp.id) as student_count,
  COUNT(DISTINCT CASE WHEN sp.last_login > NOW() - INTERVAL '24 hours' THEN sp.id END) as active_students_24h,
  CASE
    WHEN sc.validity_end < TIMEZONE('utc', NOW()) THEN 'expired'
    WHEN sc.validity_start > TIMEZONE('utc', NOW()) THEN 'scheduled'
    ELSE 'active'
  END as status
FROM session_codes sc
LEFT JOIN student_profiles sp ON sc.id = sp.session_code_id
GROUP BY sc.id, sc.code, sc.validity_start, sc.validity_end, sc.is_active, sc.created_at;

-- View for student progress summary
CREATE OR REPLACE VIEW student_progress_summary AS
SELECT
  sp.id as student_profile_id,
  sp.username,
  sp.display_name,
  sp.session_code_id,
  sc.code as session_code,
  sp.created_at as joined_at,
  sp.last_login,
  COUNT(DISTINCT qp.quest_id) FILTER (WHERE qp.state = 'completed') as quests_completed,
  COUNT(DISTINCT qp.quest_id) FILTER (WHERE qp.state = 'active') as quests_active,
  SUM(qp.time_spent_seconds) as total_time_spent_seconds,
  COUNT(ce.id) as total_code_executions,
  MAX(gs.last_saved) as last_save_time
FROM student_profiles sp
LEFT JOIN session_codes sc ON sp.session_code_id = sc.id
LEFT JOIN quest_progress qp ON sp.id = qp.student_profile_id
LEFT JOIN code_executions ce ON sp.id = ce.student_profile_id
LEFT JOIN game_saves gs ON sp.id = gs.student_profile_id
GROUP BY sp.id, sp.username, sp.display_name, sp.session_code_id, sc.code, sp.created_at, sp.last_login;

-- ============================================================================
-- SAMPLE DATA FOR TESTING (OPTIONAL - Comment out for production)
-- ============================================================================

-- Uncomment below to insert sample data for testing

/*
-- Insert a test session code (valid for 30 days)
INSERT INTO session_codes (code, validity_end)
VALUES ('TEST2024', TIMEZONE('utc', NOW()) + INTERVAL '30 days');

-- Insert a test student (password: "student123" hashed with bcrypt)
INSERT INTO student_profiles (username, password_hash, session_code_id, display_name)
SELECT
  'test_student',
  '$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy', -- student123
  id,
  'Test Student'
FROM session_codes WHERE code = 'TEST2024';
*/

-- ============================================================================
-- GRANTS (if needed for specific roles)
-- ============================================================================

-- Grant usage on schema
GRANT USAGE ON SCHEMA public TO anon, authenticated;

-- Grant access to tables for authenticated users
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT SELECT ON session_code_stats TO authenticated;
GRANT SELECT ON student_progress_summary TO authenticated;

-- Grant sequence usage
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;

-- ============================================================================
-- MIGRATION COMPLETE
-- ============================================================================

COMMENT ON TABLE admin_settings IS 'Stores admin configuration and credentials';
COMMENT ON TABLE session_codes IS 'Session codes generated by admin with validity periods';
COMMENT ON TABLE student_profiles IS 'Student accounts linked to session codes (one student can have multiple profiles)';
COMMENT ON TABLE game_saves IS 'Complete game state saves for each student';
COMMENT ON TABLE quest_progress IS 'Quest-level progress tracking';
COMMENT ON TABLE objective_progress IS 'Objective-level progress tracking within quests';
COMMENT ON TABLE code_executions IS 'History of all code executions by students';
COMMENT ON TABLE learning_events IS 'General learning analytics event tracking';
